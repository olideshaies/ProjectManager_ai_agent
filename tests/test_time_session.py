# tests/test_time_session.py
import uuid
import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
# Import necessary components from your app
from app.main import app
from app.database.session import SessionLocal, engine, get_db
from app.database.base import Base
from app.models.sql_task_models import TaskDB  # Import the SQLAlchemy Task model
from app.models.time_session import TimeSessionOut # Import the Pydantic output model if needed for typing

        
@pytest.fixture(scope="module")
def db_session():
    # Drop all tables and re-create them to ensure the schema reflects the latest models
    Base.metadata.drop_all(bind=engine)
    Base.metadata.create_all(bind=engine)
    # Create a new database session
    db = SessionLocal()
    try:
        # Yield the session to be used in other fixtures or tests
        yield db
    finally:
        # Close the session after tests in this module are done
        db.close()
        # Drop all tables to clean up the database state
        # This makes tests independent of each other.
        Base.metadata.drop_all(bind=engine)

# Updated fixture for the sample task, now depends on db_session
# This fixture now creates an actual TaskDB record in the test database.
@pytest.fixture(scope="module")
def sample_task(db_session: Session): # Request the db_session fixture
    # Create an instance of the TaskDB model
    task = TaskDB(
        # Provide necessary fields, 'title' is non-nullable
        title="Test Task for Time Session",
        description="A task created during test setup."
        # id will be generated by default (uuid.uuid4)
    )
    # Add the new task object to the database session
    db_session.add(task)
    # Commit the transaction to save the task to the database
    db_session.commit()
    # Refresh the task object to load its generated ID and other defaults (like created_at)
    db_session.refresh(task)
    # Yield the created task object (now with a valid ID from the database)
    yield task
    # Optional cleanup: Delete the specific task after the module tests are done.
    # However, drop_all in db_session fixture already handles this cleanup globally.
    # db_session.delete(task)
    # db_session.commit()

def override_get_db():
    db = None
    try:
        # The `db_session` fixture provides the session via the `api_client` fixture's setup
        db = db_session_for_override
        yield db
    finally:
        # We don't close the session here; the `db_session` fixture manages its lifecycle
        pass

# This global variable will hold the session from the db_session fixture
db_session_for_override: Session | None = None

# Fixture for the FastAPI TestClient, now managing the dependency override
@pytest.fixture(scope="module")
def api_client(db_session: Session): # Request the db_session fixture
    global db_session_for_override
    # Make the session from the fixture available globally for the override function
    db_session_for_override = db_session

    # This overrides the LOCAL get_db function defined above
    app.dependency_overrides[get_db] = override_get_db

    # Create the TestClient instance using the modified app
    with TestClient(app) as client:
        # Yield the client to the test function
        yield client

    # Teardown: Remove the dependency override after tests in this module complete
    del app.dependency_overrides[get_db]
    # Clear the global variable
    db_session_for_override = None

# The test function now uses the database-backed sample_task
def test_start_and_stop(api_client: TestClient, sample_task: TaskDB, db_session: Session): # Type hint reflects it's a TaskDB
    # sample_task.id is now the UUID of the task created in the database
    task_id_str = str(sample_task.id)
    task_id_uuid = sample_task.id # Keep the UUID object
    # --- Pre-API Check --- 
    # Use the *same session* the API will use (via override) to verify the task exists
    task_in_db = db_session.get(TaskDB, task_id_uuid)
    assert task_in_db is not None, f"Task with ID {task_id_uuid} not found in DB before API call using the same session."
    assert task_in_db.id == task_id_uuid
    print(f"\nDEBUG: Task {task_id_uuid} found in DB before API call.") # Add debug print
    # --- Start Session --- 
    # Make the POST request to start a session for the created task
    print(f"DEBUG: Making POST request to /time_sessions/ with task_id: {task_id_str}") # Add debug print
    response_start = api_client.post(
        "/time_sessions/",
        json={"task_id": task_id_str, "goal": "focus on testing"}
    )
    print(f"DEBUG: Received status code: {response_start.status_code}, Response: {response_start.text}") # Add debug print
    # Assert that the session was created successfully (201 Created)
    assert response_start.status_code == 201, f"Expected 201, got {response_start.status_code}. Response: {response_start.text}"

    # Parse the response JSON and get the new session ID
    session_data = response_start.json()
    session_id = session_data.get("id")
    assert session_id is not None, "Session ID not found in response"

    # --- Stop Session ---
    # Make the PATCH request to stop the created session
    response_stop = api_client.patch(
        f"/time_sessions/{session_id}/stop",
        json={"outcome": "test completed successfully"}
    )

    # Assert that the session was stopped successfully (200 OK)
    assert response_stop.status_code == 200, f"Expected 200, got {response_stop.status_code}. Response: {response_stop.text}"

    # Assert that the response indicates a duration was calculated
    stop_data = response_stop.json()
    assert stop_data.get("duration") is not None, "Duration not found in stop response"
